0.  Pneumonoultramicroscopicsilicovolcanoconiosis is a lung disease caused by silica dust (dictionary.com). It is notable to us as the longest word in the English language (thus the longest string we have to check for).
1.  getrusage takes in an int, either RUSAGE_SELF, which is statistics for the calling process, or RUSAGE_CHILDREN, statistics for all the children of the calling process, and returns the usage meaasures according to that int by modifying the struct. It also takes in a pointer to the struct rusage, which contains variables for statistics such as time and memory.
2.  There are 16 members in a variable of type struct usage.
3.  Because the structs before and after each contain 16 members, copying all of the member's data to use in calculate isn't efficient. We only use ru_utime.tv_sec, so it makes more sense to pass in the location of that value, rather than copying the whole struct.
4.  First, main checks to make sure speller is being used correctly, by verifying argc. Depending on whether a dictionary was specified, either the default or specified is loaded. There are checks in place for loading of the dictionary and file, so that if they don't load, an error message will print, and main will return 1. 
    A pointer to the file to bec checked is created, and the file is opened and read. Then, a for loop with fgetc gets the first character. If it is alphabetical, it is added to the array word, and index is increased. If the array word is too long to be a word, the index is moved back to 0, and whatever was written in it up to that point is overwritten. The same happens if fgetc returns a number. Once fgetc returns a space, we know that the word has ended, so terminate our string word with \0. Then, the counter is updated, and the time and memory it took to scan the word is calculated. Then, main checks if the word was mispelled, reports that, and sets the index back to 0 so that another word can be scanned in.
5.  I think fscanf uses spaces to tell between strings, but in a file, many times a word ends with something that's not a letter, but also not a space, such as a period or comma. fscanf would see that as part of the word, but fgetc simply recognizes it as not an alphabetical character. NOTE: fscanf can be used for dictionary files, because each word is on its own line with a space after
6.  From what I can tell, const char* means that we can change the pointer to word, but we cannot change word itself. This might be a way to minimize error, because I cannot accidently change the contents of word or dictionary within the function.
7.  I used a hashtable of size 65536 and a hashing function I found on Reddit. Each element of the hashtable where something is stored is a pointer to the first node in a linked list of all the elements at that index.
8.  .08 seconds, .04 in load, .02 in check, and .02 in unload for austen.txt
9.  Rather than check automatically going into a while loop at an element in the hashtable with something in it, it first checks if the beginning of the linked list is the right word. It only enters the while loop if the word to be matched is second or later on the linked list, which isn't very often (because there aren't that many collisions)
10. I don't really think so, at least not ones I could fix with my current abilities. I do think that since the number of nodes in the dictionary shouldn't change with each run of the program, I should be able to declare them as global variables and not malloc each one as necessary, which would hypotetically make load a lot faster. However, it wouldn't affect check, which is where the majority of the time comes from in long texts.  